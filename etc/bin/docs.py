from pathlib import Path
import re
import sys
from urllib.parse import urljoin

from sphinx.ext.intersphinx import fetch_inventory


CYLC_DOC_URL = 'https://cylc.github.io/cylc-doc/'

DOC_FILE = Path('cylc', 'flow', 'doc.py')

DOC_FILE_TEMPLATE = '''
# THIS FILE IS PART OF THE CYLC WORKFLOW ENGINE.
# Copyright (C) NIWA & British Crown (Met Office) & Contributors.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Mapping of Sphinx "objects" to documentation URLs.

These URLs are for use in warnings and error messages.

This file is autogenerated by {__file__}, to register new "objects"
please add them to {__file__} and rebuild this file.

Use "from _ import _" rather than "import _" to import references from this
file so that they result in import errors if the reference is removed.

"""

{objects}
'''

LABELS = [
    # ('std:term', 'workflow'),
    # ('std:label', '728.cheat_sheet'),
    # ('cylc:conf', 'flow.cylc')
    ('std:label', 'majorchangesplatforms'),
    ('std:label', 'cylc_7_compat_mode'),
    ('cylc:setting', 'flow.cylc[scheduler]allow implicit tasks'),

]


def get_url(tag='latest', fmt='html'):
    """Return the cylc-doc root URL.

    Args:
        tag: The docs version e.g. "stable" or "latest".
        fmt: The docs format e.g. html or slides.

    """
    return urljoin(CYLC_DOC_URL, f'{tag}/{fmt}/')


def get_url_mapping(base_url):
    """Return an object:url mapping for all objects documented in base_url."""
    # mock objects needed for loading the inventory outside of a Sphinx app
    # see sphinx.ext.intersphinx.inspect_main for details

    class MockConfig:
        intersphinx_timeout = None
        tls_verify = False
        user_agent = None

    class MockApp:
        srcdir = ''
        config = MockConfig()

    def warn(self, msg: str) -> None:
        print(msg, file=sys.stderr)

    # load the inventory file
    inv_file = urljoin(base_url, 'objects.inv')
    return fetch_inventory(MockApp(), '', inv_file)


def resolve(base_url, mapping, domain, label):
    """Return a URL for a domain:label pair.

    Args:
        base_url:
            The cylc-doc base URL.
        mapping:
            The object-url mapping.
        domain:
            The domain to look up e.g. "std:label" is the domain used by
            Sphinx's ":ref:" role in ReST files.
        label:
            The label to look up i.e. the bit in backquotes in Sphinx
            ReST files.

    """
    try:
        return urljoin(base_url, mapping[domain][label][2])
    except KeyError:
        breakpoint()
        raise Exception(domain, label)


def write(data):
    """Update the documentation label file."""
    with open(DOC_FILE, 'w') as doc_file:
        doc_file.write(
            DOC_FILE_TEMPLATE.format(
                __file__=__file__,
                objects='\n'.join(
                    (
                        f'{object_to_const(domain, label)} = '
                        f'(\n    "{url}"\n)'
                    )
                    for (domain, label), url in sorted(data.items())
                ),
            )
        )


def object_to_const(domain, label):
    """Convert a Sphinx object name to a Python variable name.

    Args:
        domain:
            The domain to look up e.g. "std:label" is the domain used by
            Sphinx's ":ref:" role in ReST files.
        label:
            The label to look up i.e. the bit in backquotes in Sphinx
            ReST files.

    """
    return re.sub(
        r'[:\s\.\[\]<>]',
        '_',
        f'{domain}_{label}',
    ).upper()


def main():
    base_url = get_url()
    mapping = get_url_mapping(base_url)
    data = {}
    for domain, label in LABELS:
        data[(domain, label)] = resolve(base_url, mapping, domain, label)
    write(data)


if __name__ == '__main__':
    main()
