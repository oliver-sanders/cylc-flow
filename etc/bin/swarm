#!/usr/bin/env bash
# THIS FILE IS PART OF THE CYLC SUITE ENGINE.
# Copyright (C) NIWA & British Crown (Met Office) & Contributors.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

usage () {
    cat << __USAGE__
swarm [OPTIONS] (build|configure|run)

Build, configure and run a swarm of docker containers for test purposes.

This swarm is both for local development and automated testing to proivde
a stable testing/development platform.

Containers ports are correctly exposed so they can be used either natively
or in virtual machines.

Commands:
    build        Build docker images.
    configure    Configure system ssh and cylc configuration files.
    deconfigure  Undo configuration changes.
    interactive  Run a docker container interactively.
    run          Run docker containers.
    ps           List running detached containers started with "run"
    kill         Kill detactched containers started with "run"

Note:
    "ps" and "kill" only track the most resent swarm of containers started
    by "run".

Options:
    -y --yes    Don't prompt.
    --debug     Runs the script with set -x for debug.
__USAGE__
    exit 0
}

set -eu

cd "$(dirname "$0")/../../"

YES=false
SSHD="$HOME/.ssh"
SSH_CONF="$SSHD/config"
CYLC_CONF="$HOME/.cylc/flow/$(cylc version)/global.cylc"
CYLC_TEST_CONF="$HOME/.cylc/flow/$(cylc version)/global-tests.cylc"
HERE="$(realpath "$PWD")"
ACTIVE_CONTAINERS="$HERE/.docker-active-containers"

prompt () {
    # the message to display
    local MSG="$1"

    if $YES; then
        return 0
    fi

    local USR=''
    while true; do
        read -rp "$MSG [y/n]: " USR
        case $USR in
            [Yy])
                return 0
                break
                ;;
            [Nn])
                return 1
                break
                ;;
        esac
    done
}

generate_keys () {
    # the name of the key to generate
    local KEY="$1"

    if ! [[ -f "$SSHD/$KEY" ]]; then
        if prompt "(Re)Generate ssh key: $KEY?"; then
            ssh-keygen \
                -t rsa \
                -b 4096 \
                -C 'docker@localhost' \
                -f "$SSHD/$KEY" \
                -P ''
        else
            exit 1
        fi
    fi
}

generate_ssh_keys () {
    local BASE='.docker-ssh-keys'
    local KEY
    mkdir "$BASE" -p

    # ssh key pair for connecting to docker containers
    KEY='cylc-docker'
    generate_keys "$KEY" "$BASE"
    cp "$SSHD/$KEY"* "$BASE"

    # ssh keys for connecting to $(hostname) from docker containers
    #KEY="docker-cylc-$(hostname -f)"
    #generate_keys "$KEY" "$BASE"
    #cp "$SSHD/$KEY"* "$BASE"
}

append_config () {
    # the line to add to the config
    local LINE="$1"
    # the config to add the line to
    local LOC="$2"
    # whether the line should appear at the top or bottom (default bottom)
    local POS=${3:-bottom}

    # create the config if not already there
    mkdir -p "$(dirname "$LOC")"
    touch "$LOC"

    # add the line to the config...
    if ! grep -q "$LINE" "$LOC"; then
        if prompt "Write \"$LINE\" to \"$LOC\"?"; then
            if [[ "$POS" == top ]]; then
                # ... at the top of the file
                sed -i "1i$LINE" "$LOC"
            elif [[ "$POS" == bottom ]]; then 
                # ... at the bottom of the file
                echo -e "\n$LINE" >> "$LOC"
            else
                # ... nowhere
                echo "Invalid position :$PWD" >&2
                exit 1
            fi

        else
            exit 1
        fi
    fi
}

# docker run opts for independent filesystem images
INDEP_FS_OPTS=(
)
# docker run opts for shared filesystem images
SHARED_FS_OPTS=(
    '-v' "$HOME/cylc-run:/root/cylc-run"
)
# docker run opts for tcp communication images
TCP_OPTS=(
    '-e' "HOST_HOSTNAME=$(hostname -f)"
)
# docker run opts for polling communication images
POLL_OPTS=(
    '-e' 'HOST_HOSTNAME=false'
)
# the lowest port to use for communicating with containers
BASE_PORT=42220

_run () {
    # run a container
    local fs="$1"  # i.e. indep, shared
    local comms="$2"  # i.e. tcp, poll
    local detached="${3:-false}"  # i.e. true, false
    local port

    # set the detach args
    local opts=()
    if ${detached}; then
        opts+=('-i')
    else
        opts+=('-d')
    fi

    # set the filesystem args
    if [[ $fs == indep ]]; then
        port=$BASE_PORT
        opts+=("${INDEP_FS_OPTS[@]}")
    elif [[ $fs == shared ]]; then
        port=$(( BASE_PORT + 10 ))
        opts+=("${SHARED_FS_OPTS[@]}")
    else
        echo "invalid fs type '$fs'" >&2
        exit 1
    fi

    # set the communications args
    if [[ $comms == tcp ]]; then
        opts+=("${TCP_OPTS[@]}")
    elif [[ $comms == poll ]]; then
        opts+=("${POLL_OPTS[@]}")
        (( port += 1 ))
    else
        echo "invalid comms method '$comms'" >&2
        exit 1
    fi

    # run docker run
    docker run \
        -t --privileged \
        -p "$port:22" \
        "${opts[@]}" \
        cylc-remote:latest
}

build () {
    # build docker images
    docker build . \
        -f dockerfiles/cylc-dev/Dockerfile \
        -t cylc-dev:latest
    docker build . \
        -f dockerfiles/cylc-remote/Dockerfile \
        -t cylc-remote:latest
}

configure () {
    # configure ssh and cylc to work with this swarm

    # generate ssh keys for host - docker image communication
    generate_ssh_keys

    # map exposed docker ports to hostnames
    append_config \
        "Include $HERE/etc/conf/ssh_config" \
        "${SSH_CONF}" \
        top  # ssh config includes must be at the top

    # map ssh hostnames to cylc platforms
    append_config \
        "%include '$HERE/etc/conf/global.cylc'" \
        "${CYLC_CONF}"
    append_config \
        "%include '$HERE/etc/conf/global.cylc'" \
        "${CYLC_TEST_CONF}"
}

deconfigure () {
    # undo configurations make in configure ()
    sed -i "\|$HERE/etc/conf|d" "${SSH_CONF}"
    sed -i "\|$HERE/etc/conf|d" "${CYLC_CONF}"
    sed -i "\|$HERE/etc/conf|d" "${CYLC_TEST_CONF}"
}

interactive () {
    # run one container interactively
    _run indep tcp true
}

run () {
    # run all containers detached
    (
        _run indep tcp
        _run indep poll
        #_run shared tcp
        #_run shared poll
    ) > "$ACTIVE_CONTAINERS"
    cat "$ACTIVE_CONTAINERS"
}

ps () {
    # list all containers started with run ()
    if [[ -f "$ACTIVE_CONTAINERS" ]]; then
        cat "$ACTIVE_CONTAINERS"
    fi
}

kill () {
    # kill all containers started with run ()
    # shellcheck disable=SC2046  # provide each line of the file as an arg
    if [[ -f "$ACTIVE_CONTAINERS" ]]; then
        docker kill $(cat "$ACTIVE_CONTAINERS")
        rm "$ACTIVE_CONTAINERS"
    fi
}

cmds=()
for arg in "$@"; do
    case "$arg" in
        --help)
            usage
            ;;
        -y|--yes)
            YES=true
            ;;
        --debug)
            set -x
            ;;
        build|deconfigure|configure|run|interactive|ps|kill)
            cmds+=("$arg")
            ;;
        *)
            echo "Invalid argument '$arg'" >&2
            exit 1
    esac
done

if [[ ${#cmds[@]} -eq 0 ]]; then
    usage
fi

for cmd in "${cmds[@]}"; do
    "${cmd}"
done
